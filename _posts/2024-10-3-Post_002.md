---
title: RECONNAISSANCE & WEAPONIZATION
date: 2024-10-03 00:00:00 -05:00
categories: [cibersecurity, kill chain, pentesting]
tags: [reconnaissance, weaponization, kali, metasploit]  # TAG names should always be lowercase
---

# REPASO Y MÁS SOBRE RECONNAISSANCE 
##  Comando *netstat* (Windows)

Para ver estados de las conexiones, indica protocolo (TCP), la dirección IP del puerto, nombre de dominio del host local y el puerto abierto en el servicio respectivo:
![alt text](/assets/images/image12.png)

Usando el flag *-an* donde el *a* indica todas las conexiones y puertos en escucha (listening) y la *n* indica las direcciones y puertos ordenados numéricamente.
```bash
netstat -an
```
![alt text](/assets/images/image17.png)
![alt text](/assets/images/image13.png)


Para  conocer mejor cada opción o flag, se puede usar el flag **-h** (help)para observar los demás parámetros del comando *netstat*:
```bash
netstat -h
```

![alt text](/assets/images/image11.png)


Hay 2 tipos de escaneos:
- SYN-Stealth SCAN (visto en la sección [Anterior](/posts/Post_001))
- TCP Connect Scan
![alt text](/assets/images/image10.png)

- -p- --> Para escanear sobre todos los puertos.
- -sV --> script de Versiones: realiza escaneos con verificación de servicios (donde el script tenga un servicio configurado), indicando sus versiones para conocer que vulnerabilidades se pueden explotar.

### Proceso de handshake SYN-ACK
![alt text](/assets/images/image14.png)

Otro tipo de escaneo con TCP
** TAREA: BUSCAR MAS INFORMACION, RECOPILAR LOS PUERTOS NORMALMENTE ABIERTOS, O QUE VAN A SER FILTRADOS POR EL FIREWALL
Ejemplos vistos: 135 445 (filtrados) **

EL KALI LINUX tiene variedad de herramientas para , otra aplicación útil es Shireshark, que cumple la función de _"sniffer"_ (olfateador) para dar seguimiento al flujo de datos, paquetes y conexiones entre hosts, servidores, puertos, etc.

ip addr show
Indicar las direcciones IP del host (Linux)
![alt text](/assets/images/image15.png)
Se observan las direcciones de LOOPBACK y ETHERNET 0.

# WEAPONIZATION
EL Kali Linux cuenta con herramientas de Metasploit (scripts de consultas, busqueda, etc), los sploites son para *explotar* vulnerabilidad de los *target*. Por otro lado el Metasploitable (basado en Windows 2008) cuenta con muchas vulnerabilidades que facilitaran el aprendizaje de los procesos de hacking en un Pentester. 
Para ingresar a las herramientas de *Metasploit* en Kali Linux, se utiliza el siguiente comando (dentro de una consola o terminal):
```bash
msfconsole -q
```
![alt text](/assets/images/msfconsole.png)


## Pasos de *Weaponization*
### 1) Búsqueda de Scripts de Metasploit
El primer paso es enumerar o listar los usuarios que responden en un intento de conexión de forma remota. 

ATAQUE DE FUERZA BRUTA: Cuando no se limita el número de intentos en el ingreso de credenciales (user & password), se puede realizar muchos intentos con una base de datos hasta encontrar las credenciales de un usuario.

Comando *search* en msfconsole para buscar script relacionados con algun protocolo o indicador como por ejemplo para buscar script con los indicadores *ssh* y *enum*

```bash
msf6 > search ssh enum
```
![alt text](/assets/images/image16.png)

De las opciones observadas, la opción ....
El script hace el intento de conexión entre pares de usuario y contraseñas de una base de datos de usuarios y contraseñas comúnes.

Para realizar una conexión SSH, no se reconoce si la conexión se realizará con el objetivo deseado. Como se indica a continuación.

Se ingresa a la herramienta **scanner/ssh/ssh_enumusers**. Una vez ingresado al apartado de la herramienta *ssh_enumusers* se utiliza el comando *show options* para ver que opciones se deben configurar para realizar el proceso de busqueda de las credenciales del hosts objetivo.
![alt text](/assets/images/enumusers.png)

### 2) Búsqueda de diccionarios o tablas (base de datos)
Para utilizar está herramienta se requiere de *DICCIONARIOS* o listas de nombres de usuarios y contraseñas comunes. Estos datos se pueden encontrar en repositorios como GITHUB, GITLAB u otras fuentes onlines.
Repositorio de ejemplo a usar: *https://github.com/danielmiessler/SecLists/blob/master/Usernames* donde los elementos a descargar son: *CommonAdminBase64.txt* y *top-usernames-shortlist.txt*
![alt text](/assets/images/seclist_usernames.png)
![alt text](/assets/images/seclists.png)

### 3) Configurar y asignar valores (rutas, valores, direcciones,etc)
1) USERFILE
Una vez descargados y ubicados en una carpeta conocida (como Downloads), se usa el comando *set* para cambiar o asignar la ruta de la base de datos con nombres de usuarios. Posteriormente se vuelve a consultar y verificar si se cambio la ruta usando el comando *show options*.
![alt text](/assets/images/setUserFile.png)

2) RPORT
El RPORT, está configurado por defecto en el puerto 22 (SSH), pero puede ser configurado SSH en otro puerto, y se tiene que cambiar el valor *'x'*.
```bash
msf6 auxiliary(scanner/ssh/ssh_enumusers) > set RPORT x
```
3) RHOSTS
Para asignar o cambiar la dirección de HOST objetivo a intentar encontrar sus credenciales.
```bash
msf6 auxiliary(scanner/ssh/ssh_enumusers) > set RHOSTS 10.0.2.4
```
![alt text](/assets/images/Rhosts_options.png)

4) VERBOSE & RUN
Se cambia el valor de **VERBOSE** a *true*. 
```bash
msf6 auxiliary(scanner/ssh/ssh_enumusers) > set VERBOSE true
```
Una vez asignados estos valores, se continua con el comando *run*
```bash
msf6 auxiliary(scanner/ssh/ssh_enumusers) > run
```
![alt text](/assets/images/run_enum_match.png)
![alt text](/assets/images/run_enum_match2.png)
De los resultados obtenidos, se observan que se encontraron 3 nombres de usuarios que emparejaron con el host objetivo (victima):
- Administrator: Administrator:QWRtaW5pc3RyYXRvcg==
- Guest: Guest:dWVzdA==
- vagrant: vagrant:dmFncmFudA==
De momento, solo se detectan los nombres de usuarios. NOTA: Se debe respetar la asignación de mayúsculas y minúsculas de los nombres (no es lo mismo *vagrant* y *Vagrant*).
Una vez visto este proceso, ¿cómo es que funciona?

### PARTES Y FUNCIONAMIENTO DE *ssh_enum_users*
Este script del sploit de OpenSSH está diseñado en lenguaje Ruby y su funcionamiento se basa principalmente en estas subfunciones o rutinas:
1) **initialize** : Es una función que registra los valores configurados tanto en consola (como RHOSTS, RPORT, THRESHOLD, USER_FILE vistos previamente) y también valores por defecto (como el método de ataque por   _malformed_packet_, tiempos de ejecución por usuario, etc). Esta función deriva los valores, tipos y arreglos dados hacia las demás funciones del script.

2) **check_user** : Recibe los parámetros de *user*, *ip* y *port*. Con esta función se realiza la verificación de la existencia de un nombre de usuario configurado en el host objetivo usando 2 métodos: *malformed packet* y *timing attack* empleando los métodos de autenticación de *password* o *keyboard-interactive*.
- *MALFORMED PACKET (paquete malformado)*: Se envía un paquete malformado o corrupto, ya que en algunas versiones de openSSH, estos paquetes alteran el formato de autenticación y presentan un retardo al procesar e intentar verificar la existencia de un usuario configurado (solicitud de verificación). Pero de no existir el usuario, el servidor rechaza la conexión rápidamente.
- *TIMING ATTACK (ataque de tiempo)*: Esta técnica se basa en la medición precisa de los tiempo de respuesta de un servidor SSH al responder una solicitud de autenticación, si se rechaza muy rápido una autenticación el usuario no existe, pero esa diferencia en ocasiones puede ser muy ínfima. Este método puede verse afectado por la carga en servidores u otros factores de red. En ocasiones, el tiempo de respuesta entre un usuario válido y otro que no, puede ser muy pequeña, por eso es más dificil de detectar que el paquete malformado.

3) **attempt_user** : Esta función verifica la cantidad de intentos de conexión (por defecto está configurado para 3 intentos por nombre de usuario). Está función utiliza como parámetros a *user* y *ip*, e invoca a la función **check_user** para evaluar su estado de autenticación y derivar a otra función o repetir el proceso.

4) **user_list** : Almacena en una matriz o arreglo los datos de los nombres de usuarios configurados, este lo obtiene de 3 formas: con USERNAME configurado previamente, USER_FILE (archivo .txt en almacenamiento) o DB_ALL_USERS. Esta función utiliza el método **.uniq** de *ruby* para filtrar los nombres repetidos.

5) **show_results** : Tiene la finalidad de mostrar los estados de las autenticaciones en consola, indicando los siguientes valores:
- *success*: Si se encontró un nombre de usuario válido.
- *connection_error*: Si hubo un error de conexión con el host o servidor.
- *fail*: Cuando no se encontró un usuario válido.

6) **Otras funciones** : También hay otras subrutinas para la ejecución, reportes, generador de cadena de texto aleatorio y otros que complementan el funcionamiento del script.

### ¿Cómo debemos almacenar los nombres de usuarios válidos?

1) **De forma manual:**
Una manera de almacenar estos valores son en _diccionarios_ utilizando la herramienta _nano_ de Linux para poder crear y abrir un archivo de texto (.txt) para copiar y pegar los nombres y guardar. O también creando un archivo .txt en escritorio u otra carpeta que invocará y asignará como parámetros posteriormente.


![alt text](/assets/images/nano_1.png)
![alt text](/assets/images/archivo_usuarios_validos.png)
![alt text](/assets/images/usuarios_nano_2.png)

<p style="font-size: 40px; color: red; font-weight: 900">
REVISAR OTRAS ALTERNATIVAS ... FUNCIONES ? SCRIPTS?
</p>

## MÁS HERRAMIENTAS DE *WEAPONIZATION*

### **Script ssh_login**
Ahora se realizará la búsqueda de otro *sploit* para encontrar y completar las credenciales del usuario objetivo. Usando el comando search con los *keywords: ssh y login*. Esta búsqueda genera 15 resultados, cada una para un propósito y ciertas vulnerabilidades, pero en esta ocasión se utilizará el scrip N°15 **ssh_login**. 
![alt text](/assets/images/search_login.png)

SSH LOGIN realiza un escaneo (mediante _*_ataque de fuerza bruta_) para verificar los credenciales de logeo.
De manera similar que el script ssh_enumusers se debe configurar algunos archivos, modos y valores iniciales. 
Usando el siguiente código para utilizar el módulo:
```bash
msf6 > use auxiliary(scanner/ssh/ssh_login) 
```
Y luego este comando para ver las opciones:
```bash
msf6 auxiliary(scanner/ssh/ssh_login) > show options
```
![alt text](/assets/images/search_login_options.png)

### Pasos para la configuración del script *ssh_login*
Los pasos son similares a los realizados con el script ssh_enumusers, ahora añadiendo una lista con contraseñas de un repositorio.

1) **RHOSTS**
Para asignar la dirección IP del host objetivo, como se indica a continuación:
```bash
msf6 auxiliary(scanner/ssh/ssh_login) > set RHOSTS 10.0.2.4
```

2) **Configuración de listas:**

- **PASS_FILE** : Lista de contraseñas a evaluar el login en el o los usuarios encontrados (válidos).
- **USER_FILE** : Lista de los nombres de usuarios válidos.
- **USERPASS_FILE** : Usuarios y contraseñas, cada par en una línea y separados por un espacio. Se pueden obtener de un repositorio en github, gitlab u otras bases de datos.

Estas listas a utilizar suelen contener los usuarios y contraseñas, que en el peor de los casos, se dejaron por defecto y son comunes, y con la herramienta ssh_login se explota esta vulnerabilidad para obtener acceso a la máquina objetivo.

![alt text](/assets/images/USUARIOS_NANO_3.png)

Y posterior verificación con _show options_ :
![alt text](/assets/images/rhosts_usuarios.png)

Para la configuración de PASS_FILE se puede utilizar el repositorio:  *https://github.com/danielmiessler/SecLists/tree/master/Passwords* .

Pero para fines didácticos, se utilizará una lista previamente descargada con algunas contraseñas de prueba.
![alt text](/assets/images/listaPASS_FILE.png)
Y verificamos la carpeta asignada para PASS_FILE:
![alt text](/assets/images/setPASS.png)

Luego seteamos el VERBOSE a *true* y se ejecuta el script:
![alt text](/assets/images/verbose_run_login.png)
![alt text](/assets/images/login_run_found.png)

Se obtuvieron 2 credenciales:
- USER: Administrador - PASS: vagrant
- USER: vagrant - PASS: vagrant

Tener en cuenta que el usuario o host objetivo pudo realizar alguna configuración como un número limitado de intentos de autenticación.

### Uso de los datos obtenidos
Con las credenciales encontradas, se puede utilizar para tener acceso de forma remota al dispositivo objetivo.





